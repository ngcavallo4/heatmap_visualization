import matplotlib.pyplot as plt
from utility.krige_model import KrigeModel
from matplotlib import ticker
from utility.parse_csv import CSVParser
import numpy as np 

class KrigingPlotter():

    r"""Handles plotting the heatmaps and the variance maps.

        Parameters
        ----------

        match_steps: :class:`bool`
            A boolean passed on from organize_kriging_area.
        bin_num: :class:`int`
            Number of bins for the estimated emperical variogram.
        length_scale: Optional, :class:`float`
            Length scale of GSTools variogram.
    """

    def __init__(self, mode: list[int], bin_num: int=30, length_scale: dict = {'0': 1.0, '1': 1.0, '2': 1.0, '3': 1.0, 'all': 1.0}):
        self.mode = mode
        self.bin_num = bin_num
        self.length_scale = length_scale
        self.fig = None
        self.axs = None
        self.ncols = None

        self.initialize_subplots()

    def initialize_subplots(self):
        r"""Sets up rows of subplots based on which legs are being plotted.
        """

        nrows = 2

        if len(self.mode) > 1:
            if 'all' not in self.mode:
                self.ncols = len(self.mode) + 1
            else:
                self.ncols = len(self.mode)
        elif len(self.mode) == 1:
            self.ncols = 1
        
        self.fig, self.axs = plt.subplots(nrows,self.ncols,figsize=(17,7))
    
    def plot_heatmap(self, file: str, match_steps: bool, match_scale: bool = False,
        x_interpolation_input_range: list[float] = None,
        y_interpolation_input_range: list[float] = None):
        r"""Plots heatmap. Calls helper function based on which mode user
            decides upon initializing object – single leg or all legs.

            Parameters
            ----------
            file: :class:`str` 
                Name of the csv file where the data is stored. This file should
                be stored in /kriging/data.  
            match_steps: :class:`bool`
                Boolean that determines whether the kriging area will be fitted
                to match the input data. If False, user must input 
                x and y_interpolation_input_range.
            match_scale: :class:`bool`, optional
                Boolean that determines whether the colorbar scale for the
                interpolation plots will be consistent across images, and same
                for the varance plots. Only matters if mode is 'all'. 
            x_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
            y_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
        """
        
        csvparser = CSVParser(file)
        
        if len(self.mode) == 1:
            spirit_leg = csvparser.access_data([self.mode])
            x = spirit_leg[0].x
            y = spirit_leg[0].y
            stiff = spirit_leg[0].stiff
            title = spirit_leg[0].title
            self.plot_single_mode(x, y, stiff, title, match_steps,
                                self.length_scale[self.mode],
                                x_interpolation_input_range=x_interpolation_input_range,
                                y_interpolation_input_range=y_interpolation_input_range)
        else:
            self.plot_multiple_legs(csvparser, match_steps, 
                            self.length_scale, match_scale,
                                x_interpolation_input_range=x_interpolation_input_range, 
                                y_interpolation_input_range=y_interpolation_input_range)

    def plot_single_mode(self, x: np.ndarray, y: np.ndarray, stiff: np.ndarray, title: str, match_steps: bool,
                        length_scale: float, x_interpolation_input_range: list = None,
                        y_interpolation_input_range: list = None):

        r"""Plots a single leg based on the passed in parameters x, y, stiff,
            and title. 

            Parameters
            ----------
            x: :class: `np.ndarray`
                Array containing x-position data. 
            y: :class: `np.ndarray`
                Array containing y-position data. 
            stiff: :class: `np.ndarray`
                Array containing stiffness data.
            title: :class:`str`
                String indiciating which leg is being plotted. Autogenerated 
                from the access_data function from the CSVParser class. 
            match_steps: :class:`bool`
                Boolean that determines whether the kriging area will be fitted
                to match the input data. If False, user must input 
                x and y_interpolation_input_range. Passed through from 
                generate_heatmap.
            match_scale: :class:`bool`, optional
                Boolean that determines whether the colorbar scale for the
                interpolation plots will be consistent across images, and same
                for the varance plots. Only matters if mode is 'all'. Passed 
                through from generate_heatmap.
            x_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
                Passed through from generate_heatmap.
            y_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
                Passed through from generate_heatmap.
        """
        plt.figure(self.fig)
        krige_model = KrigeModel(x,y,stiff,self.bin_num, length_scale)
        model_type, models_dict, bin_centers, gamma = krige_model.rank_models()
        # self.plot_ranked_variogram(bin_centers, gamma, models_dict,self.axs[0], 20)
        fitted_model, r2 = krige_model.fit_model(model_type.name)
        krige_model.organize_kriging_area(match_steps, 
                                    x_interpolation_input_range, 
                                    y_interpolation_input_range)
        z_pred, var, x_interpolation_range, y_interpolation_range = krige_model.execute_kriging(model=fitted_model)

        font = {'size': 7}

        # using rc function
        plt.rc('font', **font)

        ax1 = self.axs[0]
        im1 = ax1.imshow(z_pred, origin='lower', cmap='viridis', 
                         extent=(x_interpolation_range[0], x_interpolation_range[1], 
                                 y_interpolation_range[0], y_interpolation_range[1]))
        ax1.scatter(x, y, c=stiff, edgecolors='k', cmap='viridis') 
        ax1.set_title(f'Kriging Interpolation – {title} ({fitted_model.name})')
        ax1.ticklabel_format(useOffset=False)
        # ax1.set_xlabel('X pos', fontsize = 8)
        # ax1.set_ylabel('Y pos', fontsize = 8)
        # ax1.tick_params(axis='both', which='major', labelsize=7)
        ax1.xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
        ax1.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
        plt.colorbar(im1, ax=ax1, shrink=0.5)

        ax2 = self.axs[1]
        im2 = ax2.imshow(var, origin='lower', cmap='viridis', 
                         extent=(x_interpolation_range[0], x_interpolation_range[1],
                                y_interpolation_range[0], y_interpolation_range[1]))
        ax2.set_title(f'Kriging Variance – {title} ({fitted_model.name})')
        ax2.ticklabel_format(useOffset=False)
        # ax2.set_xlabel('X pos', fontsize = 8)
        # ax2.set_ylabel('Y pos', fontsize = 8)
        # ax2.tick_params(axis='both', which='major', labelsize=7)
        ax2.xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
        ax2.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
        plt.colorbar(im2, ax=ax2, shrink=0.5)
        plt.tight_layout()
        plt.show()

    
    def plot_multiple_legs(self, csvparser: CSVParser, match_steps: bool, length_scale: dict,
                    match_scale: bool = False, x_interpolation_input_range: list = None, 
                    y_interpolation_input_range: list = None): 

        r"""Plots all four legs individually and four legs together. 

            Parameters
            ----------
            csvparser: :class:`CSVParser`
                CSVParser object initialized with the filename from generate_
                heatmap. 
            match_steps: :class:`bool`
                Boolean that determines whether the kriging area will be fitted
                to match the input data. If False, user must input 
                x and y_interpolation_input_range. Passed through from 
                generate_heatmap.
            match_scale: :class:`bool`, optional
                Boolean that determines whether the colorbar scale for the
                interpolation plots will be consistent across images, and same
                for the varance plots. Only matters if mode is 'all'. Passed 
                through from generate_heatmap.
            x_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
                Passed through from generate_heatmap.
            y_interpolation_input_range: :class:`list[float]`, optional
                Only necessary to provide if match_steps is False. This is a
                array of length 2, where the 0th index is the lower bound
                of the range, and the 1st index is the upper bound of the range.
                Passed through from generate_heatmap.
        """


        z_pred_list = []
        var_list = []
        kriging_results = {}

        for request in self.mode:
            spirit_leg = csvparser.access_data([request])
            x = spirit_leg[0].x
            y = spirit_leg[0].y
            stiff = spirit_leg[0].stiff
            title = spirit_leg[0].title
            krige_model = KrigeModel(x, y, stiff, self.bin_num, length_scale[request])
            model_type, models_dict, bin_centers, gamma = krige_model.rank_models()
            # self.plot_ranked_variogram(bin_centers, gamma, models_dict,self.axs[0], 20)
            fitted_model, r2 = krige_model.fit_model(model_type.name)
            x_interpolation_range, y_interpolation_range = krige_model.organize_kriging_area(match_steps, 
                                              x_interpolation_input_range, 
                                              y_interpolation_input_range)
            z_pred, var, x_interpolation_range, y_interpolation_range = krige_model.execute_kriging(fitted_model)                

            try:
                axis_index = int(request)
            except ValueError:
                axis_index = self.ncols - 1

            z_pred_list.append(z_pred)
            var_list.append(var)
            kriging_results[request] = (z_pred, var, x, y, stiff, title, fitted_model,
                                        x_interpolation_range,
                                        y_interpolation_range,
                                        axis_index)

        zmin, zmax, var_min, var_max = self.get_global_color_limits(z_pred_list, var_list)

        for request, (z_pred, var, x, y, stiff, title, fitted_model, x_interpolation_range, y_interpolation_range,
                        axis_index) in kriging_results.items():
            

            font = {'size': 7}
            plt.rc('font', **font)

            ax1 = self.axs[0, axis_index]
            im1 = ax1.imshow(z_pred, origin='lower', cmap='viridis', 
                             extent=(x_interpolation_range[0], x_interpolation_range[1],
                                    y_interpolation_range[0], y_interpolation_range[1]))
            
            if match_scale:
                im1.norm.autoscale([zmin,zmax])
            ax1.scatter(x, y, c=stiff, edgecolors='k', cmap='viridis') 
            ax1.set_title(f'Kriging Interpolation – {title} ({fitted_model.name})')
            ax1.ticklabel_format(useOffset=False)
            # ax1.set_xlabel('X pos', fontsize = 8)
            # ax1.set_ylabel('Y pos', fontsize = 8)
            ax1.tick_params(axis='both', which='major', labelsize=7)
            ax1.xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
            ax1.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
            self.fig.colorbar(im1, ax=ax1, shrink=0.7) # format=ticker.StrMethodFormatter("{x:.7f}"), shrink=0.7)

            ax2 = self.axs[1, axis_index]
            im2 = ax2.imshow(var, origin='lower', cmap='viridis', 
                             extent=(x_interpolation_range[0], x_interpolation_range[1],
                                      y_interpolation_range[0], y_interpolation_range[1]))
            if match_scale:
                im2.norm.autoscale([var_min,var_max])
            ax2.set_title(f'Kriging Variance – {title} ({fitted_model.name})')
            ax2.ticklabel_format(useOffset=False)
            # ax2.set_xlabel('X pos', fontsize = 8)
            # ax2.set_ylabel('Y pos', fontsize = 8)
            ax2.tick_params(axis='both', which='major', labelsize=7)
            ax2.xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
            ax2.yaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True))
            self.fig.colorbar(im2, ax = ax2, shrink=0.7)# format=ticker.StrMethodFormatter("{x:.7f}"))

        plt.tight_layout()
        plt.show()

    def plot_ranked_variogram(self, bin_center, gamma, models_dict, ax, vario_x_max: float=30.0):
        r"""Plots emperical variogram, and different variogram models fitted
            to the empirical variogram. NOTE: Probably buggy. 

            Parameters
            ----------

            bin_center: :class:`np.ndarray`
                Bin centers as returned by gs.vario_estimate. 
            gamma: :class:`np.ndarray`
                Empirical semivariogram value as found by gs.vario_estimate.
                Plotted against bin_center to make up empirical variogram
                to be fitted against. 
            models_dict: :class:`dict`
                Dictionary of models to iterate through to find best fitting
                model.
            ax: :class:`mpl.Axes`   
                Instance of mpl.Axes to be plotted on.
            vario_x_max: :class:`float`, optional
                X maximum for variogram plot, default is x = 30. 

        """

        plt.figure(self.fig)
        ax.scatter(bin_center, gamma, color="k", label="data",)
        ax.set_title("Variogam model comparison – 2 traversals")
        ax.set_xlabel("Lag distance")
        ax.set_ylabel("Semivariogram")

        for fit_model in models_dict.values():
            fit_model.plot(fig=self.fig,x_max=vario_x_max, ax=ax)
        
        plt.tight_layout()

    def plot_variogram(self, model, ax):
        r"""Plot variogram based on passed in model.

            Parameters
            ----------

            model: :class:`gs.CovModel` or CovModel wrapper
                Variogram model to be plotted.
        """
        plt.figure(self.fig)
        model.plot(ax=ax)
        ax.set_title(f"Fitted {model.name} Variogram")
        ax.set_xlabel("Lag distance")
        ax.set_ylabel("Semivariogram")
        plt.tight_layout()

    def get_global_color_limits(self, z_pred_list: list[np.ndarray], var_list: list[np.ndarray]):

        r"""Calculates the global color minimum and maximum for both z_pred
        and var based on outputs of every plot.

            Parameters
            ----------

            z_pred_list: :class:`list[np.ndarray]`
                List of each plot's interpolation array.
            var_list: :class:`list[np.ndarray]`
                List of each plot's variance array.
            
            Returns
            -------

            global_z_min: :class:`float`
                Global interpolation minimum for colorbar.
            global_z_max: :class:`float`
                Global interpolation maximum for colorbar.
            global_var_min: :class:`float`
                Global variance minimum for colorbar.
            global_var_max: :class:`float`
                Global variance maximum for colorbar.
        """

        global_z_min = float('inf')
        global_z_max = float('-inf')
        global_v_min = float('inf')
        global_v_max = float('-inf')

        for z_pred in z_pred_list:
            global_z_min = min(global_z_min, z_pred.min())
            global_z_max = max(global_z_max, z_pred.max())

        for var in var_list:
            global_v_min = min(global_v_min, var.min())
            global_v_max = max(global_v_max, var.max())

        return global_z_min, global_z_max, global_v_min, global_v_max